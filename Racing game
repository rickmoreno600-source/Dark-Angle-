<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bowser Racer ‚Äî Single File</title>
  <style>
    :root{
      --bg:#0b0b0b;
      --card:#222;
      --accent:#ffcc00;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:linear-gradient(#0b0b0b,#151515);font-family:Inter,system-ui,Segoe UI,Arial; -webkit-font-smoothing:antialiased;}
    .container{min-height:100vh;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:20px;position:relative;}
    canvas{background:#333;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.6);max-width:100%;height:auto;display:block;}
    .controls{margin-top:12px;display:flex;gap:8px;align-items:center;justify-content:center;}
    .controls button{background:var(--card);color:#fff;border:0;padding:10px 14px;border-radius:8px;font-size:18px;cursor:pointer;box-shadow:0 4px 12px rgba(0,0,0,0.5);}
    .controls button:active{transform:translateY(1px);}
    .hud { position: absolute; top: 12px; left: 18px; color: #fff; font-weight:600; text-shadow:0 2px 6px rgba(0,0,0,0.7); }
    .overlay { position: absolute; inset: 0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
    .overlay .card { pointer-events:auto; background:rgba(0,0,0,0.6); color:white; padding:18px 22px; border-radius:10px; text-align:center; }
    @media (max-width:540px){ .controls button{padding:12px 16px;font-size:20px;} }
  </style>
</head>
<body>
  <main class="container">
    <canvas id="gameCanvas" width="400" height="650" aria-label="Bowser Racer game canvas"></canvas>

    <div class="controls" aria-hidden="true">
      <button id="btn-left" aria-label="Left">‚óÄ</button>
      <button id="btn-right" aria-label="Right">‚ñ∂</button>
      <button id="btn-pause" aria-label="Pause">Pause</button>
    </div>

    <div class="hud" id="hud">Score: 0</div>

    <div class="overlay" id="overlay">
      <div class="card" id="overlayCard">
        <h2 id="overlayTitle">Bowser Racer</h2>
        <p id="overlayText">Tap / Press Space to start<br>Use ‚Üê ‚Üí or tap left/right to steer</p>
        <div style="margin-top:8px;">
          <button id="startBtn" style="padding:8px 12px;border-radius:6px;border:0;background:var(--accent);cursor:pointer;">Start</button>
        </div>
      </div>
    </div>
  </main>

  <script>
  (function () {
    // Single-file lane-based racer with synthesized sounds (WebAudio)
    // Constants
    const CANVAS_WIDTH = 400;
    const CANVAS_HEIGHT = 650;
    const ROAD_PADDING = 40;
    const LANE_COUNT = 3;
    const BASE_SPEED = 160; // px / second
    const MAX_SPEED = 420;

    // Utils
    function rand(a,b){ return a + Math.random()*(b-a); }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function getLaneX(laneIndex, carWidth){
      const roadLeft = ROAD_PADDING;
      const roadRight = CANVAS_WIDTH - ROAD_PADDING;
      const roadWidth = roadRight - roadLeft;
      const laneWidth = roadWidth / LANE_COUNT;
      const laneCenter = roadLeft + laneWidth * (laneIndex + 0.5);
      return Math.round(laneCenter - carWidth / 2);
    }
    function rectsIntersect(a, b){
      return (
        a.x < b.x + b.width &&
        a.x + a.width > b.x &&
        a.y < b.y + b.height &&
        a.y + a.height > b.y
      );
    }

    // SoundManager: uses WebAudio to synthesize engine (loop), coin (tone), crash (noise burst)
    class SoundManager {
      constructor() {
        this.enabled = true;
        this.ctx = null;
        this.engine = { osc: null, gain: null };
      }

      _ensureCtx(){
        if (!this.ctx) {
          try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          } catch(e) {
            this.ctx = null;
          }
        }
      }

      enable(v = true){
        this.enabled = v;
        if (!v) this.stopAll();
      }

      resumeIfNeeded() {
        this._ensureCtx();
        if (this.ctx && this.ctx.state === 'suspended') {
          return this.ctx.resume();
        }
        return Promise.resolve();
      }

      startEngine() {
        if (!this.enabled) return;
        this._ensureCtx();
        if (!this.ctx) return;
        if (this.engine.osc) return; // already running

        // Create a subtle engine rumble using two oscillators + gain
        const o = this.ctx.createOscillator();
        o.type = 'sawtooth';
        o.frequency.value = 80; // low rumble

        const o2 = this.ctx.createOscillator();
        o2.type = 'triangle';
        o2.frequency.value = 160;

        const gain = this.ctx.createGain();
        gain.gain.value = 0.02; // low volume

        // slight tremolo using oscillator to modulate amplitude
        const lfo = this.ctx.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = 1.8;
        const lfoGain = this.ctx.createGain();
        lfoGain.gain.value = 0.006;
        lfo.connect(lfoGain);
        lfoGain.connect(gain.gain);

        o.connect(gain);
        o2.connect(gain);
        gain.connect(this.ctx.destination);

        o.start();
        o2.start();
        lfo.start();

        this.engine.osc = [o, o2, lfo];
        this.engine.gain = gain;
      }

      stopEngine() {
        if (!this.engine.osc) return;
        for (const n of this.engine.osc) {
          try { n.stop(); } catch {}
          try { n.disconnect(); } catch {}
        }
        try { this.engine.gain.disconnect(); } catch {}
        this.engine.osc = null;
        this.engine.gain = null;
      }

      playCoin(){
        if (!this.enabled) return;
        this._ensureCtx();
        if (!this.ctx) return;

        const o = this.ctx.createOscillator();
        o.type = 'sine';
        o.frequency.setValueAtTime(1100, this.ctx.currentTime);
        o.frequency.exponentialRampToValueAtTime(1600, this.ctx.currentTime + 0.12);

        const g = this.ctx.createGain();
        g.gain.value = 0.0015;
        g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + 0.15);

        o.connect(g);
        g.connect(this.ctx.destination);
        o.start();
        o.stop(this.ctx.currentTime + 0.16);
      }

      playCrash() {
        if (!this.enabled) return;
        this._ensureCtx();
        if (!this.ctx) return;

        const bufferSize = this.ctx.sampleRate * 0.35; // 350ms noise
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          // decaying white noise
          data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
        }
        const src = this.ctx.createBufferSource();
        src.buffer = buffer;
        const g = this.ctx.createGain();
        g.gain.value = 0.2;
        g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.25);
        src.connect(g);
        g.connect(this.ctx.destination);
        src.start();
      }

      stopAll(){
        this.stopEngine();
      }
    }

    // Input manager (keyboard + pointer taps)
    class Input {
      constructor(canvas) {
        this.left = false;
        this.right = false;
        this._onKeyDown = (e) => {
          if (e.key === "ArrowLeft") this.left = true;
          if (e.key === "ArrowRight") this.right = true;
        };
        this._onKeyUp = (e) => {
          if (e.key === "ArrowLeft") this.left = false;
          if (e.key === "ArrowRight") this.right = false;
        };
        this._onPointerDown = (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          if (x < rect.width / 2) this.left = true;
          else this.right = true;
        };
        this._onPointerUp = () => { this.left = false; this.right = false; };

        window.addEventListener("keydown", this._onKeyDown);
        window.addEventListener("keyup", this._onKeyUp);
        canvas.addEventListener("pointerdown", this._onPointerDown);
        canvas.addEventListener("pointerup", this._onPointerUp);
        canvas.addEventListener("pointercancel", this._onPointerUp);
      }
      destroy(canvas) {
        window.removeEventListener("keydown", this._onKeyDown);
        window.removeEventListener("keyup", this._onKeyUp);
        canvas.removeEventListener("pointerdown", this._onPointerDown);
        canvas.removeEventListener("pointerup", this._onPointerUp);
        canvas.removeEventListener("pointercancel", this._onPointerUp);
      }
    }

    // Game
    class Game {
      constructor(canvas, hud, overlay) {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.hud = hud;
        this.overlay = overlay;
        this.sound = new SoundManager();

        this.car = { lane: Math.floor(LANE_COUNT/2), width: 40, height:70, y: CANVAS_HEIGHT - 110, color:"#00ff00" };
        this.obstacles = [];
        this.score = 0;
        this.speed = BASE_SPEED;
        this.roadOffset = 0;
        this.spawnTimer = 0;
        this.nextSpawn = rand(0.8,1.4);
        this.state = "start"; // start, running, paused, gameover

        this._setupCanvas();

        this._last = 0;
        this._raf = null;
      }

      _setupCanvas(){
        const ctx = this.ctx;
        const dpr = window.devicePixelRatio || 1;
        this.canvas.style.width = `${CANVAS_WIDTH}px`;
        this.canvas.style.height = `${CANVAS_HEIGHT}px`;
        this.canvas.width = Math.floor(CANVAS_WIDTH * dpr);
        this.canvas.height = Math.floor(CANVAS_HEIGHT * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      start() {
        // Resume audio context on user interaction (most browsers require this)
        this.sound.resumeIfNeeded().catch(()=>{});
        this.score = 0;
        this.obstacles.length = 0;
        this.spawnTimer = 0;
        this.nextSpawn = rand(0.8,1.4);
        this.speed = BASE_SPEED;
        this.roadOffset = 0;
        this.car.lane = Math.floor(LANE_COUNT/2);
        this.state = "running";
        this.sound.startEngine();
        this._last = 0;
        if (!this._raf) this._raf = requestAnimationFrame(this._loop.bind(this));
        this._updateHUD();
        this._hideOverlay();
      }

      pauseToggle() {
        if (this.state === "running") {
          this.state = "paused";
          this.sound.stopEngine();
          this._showOverlay("Paused", "Press Pause or Space to resume");
        } else if (this.state === "paused") {
          this.state = "running";
          this.sound.startEngine();
          this._last = 0;
          this._hideOverlay();
          if (!this._raf) this._raf = requestAnimationFrame(this._loop.bind(this));
        }
      }

      gameOver() {
        this.state = "gameover";
        this.sound.playCrash();
        this.sound.stopEngine();
        this._showOverlay("üí• Game Over", `Score: ${Math.floor(this.score)}<br>Press R or tap to restart`);
      }

      moveLeft() { this.car.lane = clamp(this.car.lane - 1, 0, LANE_COUNT - 1); }
     
