<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bowser Racer ‚Äî Single File</title>
  <style>
    :root{
      --bg:#0b0b0b;
      --card:#222;
      --accent:#ffcc00;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:linear-gradient(#0b0b0b,#151515);font-family:Inter,system-ui,Segoe UI,Arial; -webkit-font-smoothing:antialiased;}
    .container{min-height:100vh;display:flex;align-items:center;justify-content:center;flex-direction:column;padding:20px;position:relative;}
    canvas{background:#333;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,0.6);max-width:100%;height:auto;display:block;}
    .controls{margin-top:12px;display:flex;gap:8px;align-items:center;justify-content:center;}
    .controls button{background:var(--card);color:#fff;border:0;padding:10px 14px;border-radius:8px;font-size:18px;cursor:pointer;box-shadow:0 4px 12px rgba(0,0,0,0.5);}
    .controls button:active{transform:translateY(1px);}
    .hud { position: absolute; top: 12px; left: 18px; color: #fff; font-weight:600; text-shadow:0 2px 6px rgba(0,0,0,0.7); }
    .hud .small { font-weight:400; font-size:12px; color:#ddd; display:block; margin-top:2px; }
    .overlay { position: absolute; inset: 0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
    .overlay .card { pointer-events:auto; background:rgba(0,0,0,0.72); color:white; padding:18px 22px; border-radius:10px; text-align:center; max-width:92%; }
    .sound-toggle { margin-left:6px; background:transparent; border:1px solid rgba(255,255,255,0.08); padding:6px 8px; border-radius:8px; color:#fff; cursor:pointer; }
    @media (max-width:540px){ .controls button{padding:12px 16px;font-size:20px;} }
  </style>
</head>
<body>
  <main class="container">
    <canvas id="gameCanvas" width="400" height="650" aria-label="Bowser Racer game canvas"></canvas>

    <div class="controls" aria-hidden="true">
      <button id="btn-left" aria-label="Left">‚óÄ</button>
      <button id="btn-right" aria-label="Right">‚ñ∂</button>
      <button id="btn-pause" aria-label="Pause">Pause</button>
      <button id="btn-sound" class="sound-toggle" aria-label="Toggle sound">üîä Sound</button>
    </div>

    <div class="hud" id="hud">Score: 0<span class="small" id="highScoreText">Best: 0</span></div>

    <div class="overlay" id="overlay">
      <div class="card" id="overlayCard">
        <h2 id="overlayTitle">Bowser Racer</h2>
        <p id="overlayText">Tap / Press Space to start<br>Use ‚Üê ‚Üí or tap left/right to steer</p>
        <div style="margin-top:8px;">
          <button id="startBtn" style="padding:8px 12px;border-radius:6px;border:0;background:var(--accent);cursor:pointer;">Start</button>
        </div>
      </div>
    </div>
  </main>

  <script>
  (function () {
    // Single-file lane-based racer with synthesized sounds (WebAudio)
    // Constants
    const CANVAS_WIDTH = 400;
    const CANVAS_HEIGHT = 650;
    const ROAD_PADDING = 40;
    const LANE_COUNT = 3;
    const BASE_SPEED = 160; // px / second
    const MAX_SPEED = 420;
    const HIGH_SCORE_KEY = 'bowserRacer_highScore_v1';

    // Utils
    function rand(a,b){ return a + Math.random()*(b-a); }
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function getLaneX(laneIndex, carWidth){
      const roadLeft = ROAD_PADDING;
      const roadRight = CANVAS_WIDTH - ROAD_PADDING;
      const roadWidth = roadRight - roadLeft;
      const laneWidth = roadWidth / LANE_COUNT;
      const laneCenter = roadLeft + laneWidth * (laneIndex + 0.5);
      return Math.round(laneCenter - carWidth / 2);
    }
    function rectsIntersect(a, b){
      return (
        a.x < b.x + b.width &&
        a.x + a.width > b.x &&
        a.y < b.y + b.height &&
        a.y + a.height > b.y
      );
    }

    // SoundManager: uses WebAudio to synthesize engine (loop), coin (tone), crash (noise burst)
    class SoundManager {
      constructor() {
        this.enabled = true;
        this.ctx = null;
        this.engine = { osc: null, gain: null };
      }

      _ensureCtx(){
        if (!this.ctx) {
          try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          } catch(e) {
            this.ctx = null;
          }
        }
      }

      enable(v = true){
        this.enabled = v;
        if (!v) this.stopAll();
      }

      resumeIfNeeded() {
        this._ensureCtx();
        if (this.ctx && this.ctx.state === 'suspended') {
          return this.ctx.resume();
        }
        return Promise.resolve();
      }

      startEngine() {
        if (!this.enabled) return;
        this._ensureCtx();
        if (!this.ctx) return;
        if (this.engine.osc) return; // already running

        // Create a subtle engine rumble using two oscillators + gain
        const o = this.ctx.createOscillator();
        o.type = 'sawtooth';
        o.frequency.value = 80; // low rumble

        const o2 = this.ctx.createOscillator();
        o2.type = 'triangle';
        o2.frequency.value = 160;

        const gain = this.ctx.createGain();
        gain.gain.value = 0.02; // low volume

        // slight tremolo using oscillator to modulate amplitude
        const lfo = this.ctx.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = 1.8;
        const lfoGain = this.ctx.createGain();
        lfoGain.gain.value = 0.006;
        lfo.connect(lfoGain);
        lfoGain.connect(gain.gain);

        o.connect(gain);
        o2.connect(gain);
        gain.connect(this.ctx.destination);

        o.start();
        o2.start();
        lfo.start();

        this.engine.osc = [o, o2, lfo];
        this.engine.gain = gain;
      }

      stopEngine() {
        if (!this.engine.osc) return;
        for (const n of this.engine.osc) {
          try { n.stop(); } catch {}
          try { n.disconnect(); } catch {}
        }
        try { this.engine.gain.disconnect(); } catch {}
        this.engine.osc = null;
        this.engine.gain = null;
      }

      playCoin(){
        if (!this.enabled) return;
        this._ensureCtx();
        if (!this.ctx) return;

        const o = this.ctx.createOscillator();
        o.type = 'sine';
        o.frequency.setValueAtTime(1100, this.ctx.currentTime);
        o.frequency.exponentialRampToValueAtTime(1600, this.ctx.currentTime + 0.12);

        const g = this.ctx.createGain();
        g.gain.value = 0.0015;
        g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + 0.15);

        o.connect(g);
        g.connect(this.ctx.destination);
        o.start();
        o.stop(this.ctx.currentTime + 0.16);
      }

      playCrash() {
        if (!this.enabled) return;
        this._ensureCtx();
        if (!this.ctx) return;

        const bufferSize = this.ctx.sampleRate * 0.35; // 350ms noise
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          // decaying white noise
          data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
        }
        const src = this.ctx.createBufferSource();
        src.buffer = buffer;
        const g = this.ctx.createGain();
        g.gain.value = 0.2;
        g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.25);
        src.connect(g);
        g.connect(this.ctx.destination);
        src.start();
      }

      stopAll(){
        this.stopEngine();
      }
    }

    // Input manager (keyboard + pointer taps)
    class Input {
      constructor(canvas) {
        this.left = false;
        this.right = false;
        this._onKeyDown = (e) => {
          if (e.key === "ArrowLeft") this.left = true;
          if (e.key === "ArrowRight") this.right = true;
        };
        this._onKeyUp = (e) => {
          if (e.key === "ArrowLeft") this.left = false;
          if (e.key === "ArrowRight") this.right = false;
        };
        this._onPointerDown = (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          if (x < rect.width / 2) this.left = true;
          else this.right = true;
        };
        this._onPointerUp = () => { this.left = false; this.right = false; };

        window.addEventListener("keydown", this._onKeyDown);
        window.addEventListener("keyup", this._onKeyUp);
        canvas.addEventListener("pointerdown", this._onPointerDown);
        canvas.addEventListener("pointerup", this._onPointerUp);
        canvas.addEventListener("pointercancel", this._onPointerUp);
      }
      destroy(canvas) {
        window.removeEventListener("keydown", this._onKeyDown);
        window.removeEventListener("keyup", this._onKeyUp);
        canvas.removeEventListener("pointerdown", this._onPointerDown);
        canvas.removeEventListener("pointerup", this._onPointerUp);
        canvas.removeEventListener("pointercancel", this._onPointerUp);
      }
    }

    // Game
    class Game {
      constructor(canvas, hud, overlay) {
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.hud = hud;
        this.overlay = overlay;
        this.sound = new SoundManager();

        this.car = { lane: Math.floor(LANE_COUNT/2), width: 40, height:70, y: CANVAS_HEIGHT - 110, color:"#00ff00", x: 0 };
        this.obstacles = [];
        this.score = 0;
        this.speed = BASE_SPEED;
        this.roadOffset = 0;
        this.spawnTimer = 0;
        this.nextSpawn = rand(0.8,1.4);
        this.state = "start"; // start, running, paused, gameover

        this.input = new Input(this.canvas);

        this._setupCanvas();
        this._resize(); // set initial x

        this._last = 0;
        this._raf = null;

        // Bind UI controls externally
        this._onVisibilityChange = this._onVisibilityChange.bind(this);
        window.addEventListener('resize', () => this._resize());
        document.addEventListener('visibilitychange', this._onVisibilityChange);
      }

      _setupCanvas(){
        const ctx = this.ctx;
        const dpr = window.devicePixelRatio || 1;
        this.canvas.style.width = `${CANVAS_WIDTH}px`;
        this.canvas.style.height = `${CANVAS_HEIGHT}px`;
        this.canvas.width = Math.floor(CANVAS_WIDTH * dpr);
        this.canvas.height = Math.floor(CANVAS_HEIGHT * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      _resize(){
        // Make canvas fit parent container while preserving aspect ratio
        const parentW = this.canvas.parentElement.clientWidth - 40;
        const desiredW = Math.min(CANVAS_WIDTH, parentW);
        this.canvas.style.width = `${desiredW}px`;
        // recompute car.x target based on lane
        this.car.x = getLaneX(this.car.lane, this.car.width);
      }

      start() {
        // Resume audio context on user interaction (most browsers require this)
        this.sound.resumeIfNeeded().catch(()=>{});
        this.score = 0;
        this.obstacles.length = 0;
        this.spawnTimer = 0;
        this.nextSpawn = rand(0.8,1.4);
        this.speed = BASE_SPEED;
        this.roadOffset = 0;
        this.car.lane = Math.floor(LANE_COUNT/2);
        this.car.x = getLaneX(this.car.lane, this.car.width);
        this.state = "running";
        this.sound.startEngine();
        this._last = 0;
        if (!this._raf) this._raf = requestAnimationFrame(this._loop.bind(this));
        this._updateHUD();
        this._hideOverlay();
      }

      pauseToggle() {
        if (this.state === "running") {
          this.state = "paused";
          this.sound.stopEngine();
          this._showOverlay("Paused", "Press Pause or Space to resume");
          this._stopRAF();
        } else if (this.state === "paused") {
          this.state = "running";
          this.sound.startEngine();
          this._last = 0;
          this._hideOverlay();
          if (!this._raf) this._raf = requestAnimationFrame(this._loop.bind(this));
        }
      }

      gameOver() {
        this.state = "gameover";
        this.sound.playCrash();
        this.sound.stopEngine();
        this._stopRAF();
        // update high score
        const s = Math.floor(this.score);
        const best = this._getHighScore();
        if (s > best) {
          this._setHighScore(s);
        }
        this._showOverlay("üí• Game Over", `Score: ${s}<br>Press R or tap to restart`);
        this._updateHUD();
      }

      moveLeft() { this.car.lane = clamp(this.car.lane - 1, 0, LANE_COUNT - 1); }
      moveRight() { this.car.lane = clamp(this.car.lane + 1, 0, LANE_COUNT - 1); }

      _loop(ts) {
        if (!this._last) this._last = ts;
        const dt = Math.min(0.05, (ts - this._last) / 1000);
        this._last = ts;

        if (this.state === "running") {
          this._update(dt);
          this._draw();
        }

        // Keep requesting while running; stop requesting when paused or gameover (we cancel RAF there)
        if (this.state === "running") {
          this._raf = requestAnimationFrame(this._loop.bind(this));
        } else {
          this._raf = null;
        }
      }

      _update(dt) {
        // Input discrete steering from keyboard/touch: detect press -> move lane once per press
        // We'll allow holding to repeatedly step: use a small auto-repeat
        if (this.input.left) {
          if (!this._leftPressed) {
            this.moveLeft();
            this._leftPressed = true;
          }
        } else {
          this._leftPressed = false;
        }
        if (this.input.right) {
          if (!this._rightPressed) {
            this.moveRight();
            this._rightPressed = true;
          }
        } else {
          this._rightPressed = false;
        }

        // Smoothly interpolate car.x toward lane target
        const targetX = getLaneX(this.car.lane, this.car.width);
        this.car.x += (targetX - this.car.x) * clamp(dt * 12, 0, 1);

        // Move road (visual)
        this.roadOffset += this.speed * dt;
        if (this.roadOffset > 40) this.roadOffset -= 40;

        // Spawn obstacles / coins
        this.spawnTimer += dt;
        if (this.spawnTimer >= this.nextSpawn) {
          this._spawnObstacle();
          this.spawnTimer = 0;
          this.nextSpawn = rand(Math.max(0.45, 1.4 - this.score / 80), Math.max(0.6, 1.8 - this.score / 70));
        }

        // Update obstacles
        for (let i = this.obstacles.length - 1; i >= 0; i--) {
          const o = this.obstacles[i];
          o.y += this.speed * dt;
          // collision with car
          const carRect = { x: this.car.x, y: this.car.y, width: this.car.width, height: this.car.height };
          const objRect = { x: o.x, y: o.y, width: o.width, height: o.height };
          if (o.type === 'coin' && rectsIntersect(carRect, objRect)) {
            // collect
            this.obstacles.splice(i,1);
            this.score += 10;
            this.sound.playCoin();
            continue;
          } else if (o.type === 'car' && rectsIntersect(carRect, objRect)) {
            // crash
            this.gameOver();
            return;
          } else if (o.y > CANVAS_HEIGHT + 120) {
            this.obstacles.splice(i,1);
            // passing a car gives score
            if (o.type === 'car') {
              this.score += 1;
            }
          }
        }

        // Gradually increase speed with score and time
        this.speed = clamp(BASE_SPEED + this.score * 2.2, BASE_SPEED, MAX_SPEED);
        this._updateHUD();
      }

      _spawnObstacle() {
        // choose lane and type
        const lane = Math.floor(rand(0, LANE_COUNT));
        const type = Math.random() < 0.22 ? 'coin' : 'car';
        if (type === 'coin') {
          const size = 18;
          const x = getLaneX(lane, size) + (this.car.width - size) / 2;
          const y = -50;
          this.obstacles.push({ lane, type, x, y, width: size, height: size, color: '#ffcc00' });
        } else {
          // oncoming car
          const w = 40;
          const h = 60;
          const x = getLaneX(lane, w);
          const y = -120 - Math.random() * 180;
          const color = Math.random() < 0.5 ? '#ff4444' : '#ff8c00';
          this.obstacles.push({ lane, type: 'car', x, y, width: w, height: h, color });
        }
      }

      _draw() {
        const ctx = this.ctx;
        ctx.clearRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT);

        // Draw background / road
        ctx.fillStyle = '#1c1c1c';
        ctx.fillRect(0,0,CANVAS_WIDTH,CANVAS_HEIGHT);

        const roadLeft = ROAD_PADDING;
        const roadRight = CANVAS_WIDTH - ROAD_PADDING;
        const roadWidth = roadRight - roadLeft;

        // road surface
        ctx.fillStyle = '#2e2e2e';
        roundRect(ctx, roadLeft, 0, roadWidth, CANVAS_HEIGHT, 10);
        ctx.fill();

        // lane markings
        const laneWidth = roadWidth / LANE_COUNT;
        ctx.strokeStyle = 'rgba(255,255,255,0.09)';
        ctx.lineWidth = 2;
        ctx.setLineDash([18,22]);
        ctx.lineDashOffset = -this.roadOffset;
        for (let i = 1; i < LANE_COUNT; i++) {
          const x = roadLeft + i * laneWidth;
          ctx.beginPath();
          ctx.moveTo(x, 8);
          ctx.lineTo(x, CANVAS_HEIGHT - 8);
          ctx.stroke();
        }
        ctx.setLineDash([]);

        // draw obstacles
        for (const o of this.obstacles) {
          if (o.type === 'coin') {
            ctx.fillStyle = o.color;
            ctx.beginPath();
            ctx.arc(o.x + o.width/2, o.y + o.height/2, o.width/2, 0, Math.PI*2);
            ctx.fill();
            // subtle shine
            ctx.fillStyle = 'rgba(255,255,255,0.12)';
            ctx.beginPath();
            ctx.ellipse(o.x + o.width*0.65, o.y + o.height*0.35, o.width*0.22, o.height*0.14, -0.6, 0, Math.PI*2);
            ctx.fill();
          } else {
            ctx.fillStyle = o.color;
            roundRect(ctx, o.x + 4, o.y, o.width - 8, o.height, 6);
            ctx.fill();
            // windows
            ctx.fillStyle = 'rgba(255,255,255,0.14)';
            roundRect(ctx, o.x + 8, o.y + 10, o.width - 16, 16, 4);
            ctx.fill();
          }
        }

        // draw player car
        ctx.fillStyle = this.car.color;
        roundRect(ctx, this.car.x, this.car.y, this.car.width, this.car.height, 8);
        ctx.fill();
        // car details
        ctx.fillStyle = '#0a0a0a';
        roundRect(ctx, this.car.x + 6, this.car.y + 10, this.car.width - 12, 14, 4);
        ctx.fill();

        // small vignette
        ctx.fillStyle = 'rgba(0,0,0,0.06)';
        ctx.fillRect(0,0,CANVAS_WIDTH,40);
      }

      _updateHUD() {
        const s = Math.floor(this.score);
        const best = this._getHighScore();
        if (this.hud) {
          this.hud.innerHTML = `Score: ${s}<span class="small" id="highScoreText">Best: ${best}</span>`;
        }
      }

      _getHighScore() {
        try {
          const v = parseInt(localStorage.getItem(HIGH_SCORE_KEY) || '0', 10);
          return isNaN(v) ? 0 : v;
        } catch (e) { return 0; }
      }

      _setHighScore(v) {
        try { localStorage.setItem(HIGH_SCORE_KEY, String(v)); } catch (e) {}
      }

      _showOverlay(title, html) {
        const card = this.overlay.querySelector('#overlayCard');
        const t = this.overlay.querySelector('#overlayTitle');
        const p = this.overlay.querySelector('#overlayText');
        t.textContent = title;
        p.innerHTML = html;
        this.overlay.style.display = 'flex';
      }

      _hideOverlay() {
        this.overlay.style.display = 'none';
      }

      _stopRAF() {
        if (this._raf) {
          cancelAnimationFrame(this._raf);
          this._raf = null;
        }
      }

      _onVisibilityChange() {
        if (document.hidden && this.state === 'running') {
          // auto-pause when switching tabs
          th
